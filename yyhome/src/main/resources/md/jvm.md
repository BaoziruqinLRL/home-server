[toc]

## JVM
### 内存模型：
- 私有：
    1. 程序计数器：
        线程执行过程中字节码的行号记录，指示了线程运行代码时的"路线"，指示包括分支、循环、跳出等操作的下一条字节码指令
    2. 虚拟机栈：
        一个个栈帧组成，线程执行过程中的局部变量，操作数栈，动态链接，方法出口等信息;局部变量是方法运行中产生的变量；操作数栈是方法运行中产生的计算操作数，例如a+b，产生加法结果为操作数；动态链接是指向运行时常量池的连接；方法出口为方法退出地址，包括正常退出和异常退出
    3. 本地方法栈：
        线程运行本地方法时的栈，与虚拟机栈不同的是，运行的本地方法不是java编写的，其它一致
- 公有：
    1. 堆：
        jvm最大内存块，用于存放创建的对象；分为新生代（eden，s0，s1）、老年代和永久代，新生代采用标记-复制算法进行垃圾回收(Minor GC)，老年代采用标记-整理算法(Major GC、Full GC)；jdk1.8后永久代被元空间代替，元空间直接使用物理内存不再使用jvm内存，永久代主要存放元数据，包括Class，Method的元信息，永久代是方法区的具体实现
    2. 方法区：
        存放类信息、常量、静态变量以及编译后的代码；方法区是一个规范，规定了这里应该存什么，并不是实际上有这么一个区域
    3. 运行时常量池：
        jdk1.7之前属于方法区，1.7及1.7之后属于堆；存放文本字符串，final常量，类的各种限定名描述符等
        
### 垃圾回收算法
- 标记-清除：
    对未存活对象进行标记，标记完成后清除掉，缺点是会产生大量不连续的内存碎片；
- 标记-复制：
    将内存块分为两块s0和s1，假设s0为当前内存，在s0中对未存活对象进行标记，之后将存活对象复制到s1，而后一次性清空s0；
    复制过程中会STW；
    用于Eden区新生代的Minor GC；
- 标记-整理：
    对未存活对象进行标记，标记完成后清除，随后将存活对象移动至内存的一侧整齐排放；
    整理过程中会STW；
    用于老年代的Major GC；

### 垃圾回收器
- Serial。新生代单线程收集器，标记-复制算法，会stw
- ParNew。新生代多线程收集器，Serial的多线程版，其它一致
- Parallel Scavenge。新生代多线程收集器，标记-复制算法，主要关注收集过程中的吞吐量，控制吞吐量在一个合理范围
- Parallel Old。老年代多线程收集器，标记-整理算法，主要关注吞吐量
- Serial Old。老年代单线程收集器，标记-整理算法，会STW
- CMS。老年代并发收集器，标记-清除算法，主要关注最短垃圾回收停顿时间。
    1. 初始标记。根据GC roots标记获得能直接标记的对象，会stw
    2. 并发标记。根据初始标记进行并发追踪，找到它能引用的对象
    3. 重新标记。标记第二步过程中所产生的垃圾，会stw
    4. 并发清除。清除之前标记的垃圾，这一步不stw，所以会产生浮动垃圾，等待下次清理。
    此外，CMS可以设置在多少次收集之后，进行一次压缩内存，因为它采用的标记-清除算法不会整理内存，会产生内存碎片
- G1。
    1. 摒弃了分区的概念，内存中分为一块块的区域，这些区域中有的用来放新生代对象，有的用来放老年代对象，新生代的
       收集仍然是标记-复制算法，把存活对象拷贝到另一个区域。老年代的收集也是把对象从一个区域拷贝到其它区域，完成了
       部分堆的整理，所以G1是标记-复制和标记-整理的组合算法。
    2. 可预测的停顿。G1会追踪各个区的垃圾堆价值，综合回收能获得的空间大小和回收需要的时间得出一个经验值，在开始回
       收的时候优先回收价值最大的垃圾
 - 吞吐量和停顿时间的区别。个人理解是吞吐量是指 cpu执行程序任务的时间所占的比重，越大则吞吐量越高；停顿时间则是GC
   运行时STW的时间。关注吞吐量的收集器GC是交替的获取CPU时间执行GC任务，最终执行时间控制在一个合理的范围，适合于
   连续不断计算数据的服务，因为数据计算的过程是长时间且连续不可中断的；而关注停顿时间的收集器适用于WEB服务器，因为
   WEB服务的请求是不连续且可中断的，只有当全局程序都运行到安全点时，此时没有程序代码执行，才能执行STW进行GC，而吞
   吐量GC由于服务是连续运行的，所以很难达到全局安全点，故而不适用停顿时间优先的收集器。
### 对象创建过程
- 类加载检查：
    当遇到对象创建关键字时，首先检查对象对应的类是否已经被加载完成，如果没有加载完成，则先执行<a href="#类加载过程">类加载</a>
- 内存分配：
    给对象分配内存空间，在类加载完成后对象需要的内存大小就可以确定
- 初始化0值：
    对象获得了分配空间后，给对象赋予默认的0值，保证对象能在创建完成后不赋值便能使用
- 设置头信息：
    设置对象的基础信息，如GC年龄，类信息，哈希值等等
- 执行init方法：
    按照开发者的赋值构造方法进行赋值，这样新的对象就完全创建完毕
    


### 类加载过程
    类的加载实际上，就是在编译器把java文件编译成.class文件后，将其装载到jvm的方法区中，并在堆上创建Class对象的过程
- 加载：
    通过类的名字获取类文件的二进制字节流；
    将二进制字节流转成相应的方法区运行时数据；
    在堆中生成类对象；
- 验证：
    验证阶段主要是验证文件的合法性，类的属性冲突，编写格式是否符合规范等
- 准备：
    该阶段给类的静态变量分配内存并设置初始值（赋0），因为是静态变量，所以都在方法区中分配
    注意这里只会给静态变量分配，类中的实例变量依然是会随着程序运行在堆中分配
- 解析：
    将类中的符号引用转为直接引用，我理解为例如String a = s; 将转换为 String a = #{s的实际地址}
- 初始化：
    按照类的构造函数进行初始化赋值等操作，这一步的初始化就是按照用户编写的进行初始化
    
### 类加载器
- Bootstrap ClassLoader：
    最顶层的加载器，主要加载java核心库中的文件，即%JRE_HOME%/lib中的rt.jar，resources.jar等常见的核心文件
- Extension ClassLoader：
    加载扩展类，即%JRE_HOME%/lib/ext中的文件
- Appclass Loader:
    加载程序员所编写的java文件
    
### 双亲委派模型：
    当收到类加载请求的时候，首先会往上委托最顶层的加载器进行尝试加载，如果顶层加载成功，则加载完成，否则再交由顶层的
    下一级加载器进行加载；这样保证最核心的文件总是由核心加载器去加载，防止用户篡改java核心文件，以及避免重复加载；
    java中的所有的类加载器都遵循这个模型

### 内存分配
- 指针碰撞法：
    用于内存规整的内存块进行分配内存，通过一个指针作为分界点，向空闲内存移动指定大小，将该块内存分配出去；
    标记-复制 和 标记-整理 得到的是规整内存
- 空闲列表法：
    用于内存存在大量碎片的情况，维护一个空闲内存列表，需要分配时从列表中找出足够大的内存分配；
    标记-清除 得到的是碎片内存
    
### 内存分配并发问题
- CAS机制+失败重试
- TLAB：
    在堆上预先给线程分配一块内存，优先在这块内存上分配对象，当内存不够时，再使用CAS进行分配内存
    
### 逃逸分析
    分析对象的作用域，若对象在方法中被定义，但会被外部所引用，则成为方法逃逸；若在线程中定义，会被其他线程引用到，
    则成为线程逃逸；逃逸分析会对代码进行优化：
- 锁消除策略：
    如果分析发现一个对象不会发生逃逸，则会将该对象的同步锁清除；
- 堆内存分配变成栈内存分配：
    如果对象不会发生逃逸，则对象的分配将转为在栈内分配，随着栈的生命周期而清除，不会被GC介入
- 分离对象：
    java中的基础类型称为标量，对象称为聚合量，当对象不会发生逃逸时，在执行时可能不会创建对象，而是创建多个相同含义
    的标量；省去了可能在堆上分配内存以及创建对象的开销；
    
### 类型擦除
    针对泛型的一个机制，仅存在于代码编写期间，在编译期泛型就会被擦除，转而替换为具体的类型，例如T会被替换为Object，
    <T extends Base>会被替换为 Base类型，<T super Base>会被替换为Object类型， 然后在必要的地方做强转操作。
- 对于List<? extends Base>, 是一个Base的子类的List集合，但无法确定是什么类的集合，那么假如是Base的子类的集合，那么该集合
  就无法插入Base数据，因为Base无法强转成Base的子类，因此对于Add方法来说，添加类的类型是不确定的，因此不支持Add；但是
  get方法可以吧Base的子类转换成Base获取出来，所以支持Get
- 对于List<? super Base>, 是Base的父类的List集合，虽然无法确定是什么类，加入是Base的集合，那么该集合可以添加一个Base
  的子类，因为子类可以强转成Base；但如果是Base的集合，就无法添加Object类，跟extends一个道理，Object无法转换成Base，所以
  add能添加Base的子类，不能添加Base的父类；get的时候只能get出Object对象，因为所有的类都可以向上转型，因为不确定具体对象，所以
  向上转成最顶层对象
  
    
