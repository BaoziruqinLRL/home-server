[toc]

## redis

### 淘汰策略
- allKeys-lru: 淘汰使用最少的键
- volatile-lru: 在过期集合中淘汰使用最少的键
- allKeys-random: 回收随机键
- volatile-random: 在过期集合中回收随机键
- volatile-ttl: 在过期集合中回收存活时间最短的键

### 结构
- String
	1. 底层采用SDS结构实现。比字符串多了free和len用来记录字符串数组的剩余空闲空间和当前长度
- hash。键值对结构。底层使用zipList和hashTable实现，当每个键值对的长度都小于64以及总节点数小于512时，采用ziplist。否则使用hashTable，hashTable实际上就是数组+单链表的结构。zipList是压缩数组，通过特殊的操作，把所有的数据都紧紧贴合在一起存放
- List。有序集合。底层使用ziplist和linkedlist实现。当每个节点长度都小于64以及总节点数小于512时，采用ziplist。否则使用linkedlist双向链表
- Set。不可重复集合。跟hash一样，只不过当使用hashTable时，所有的value都为null
- ZSet。可排序集合。ziplist或者 字典+跳表的结构

### 主从模型
    一个节点可以有多个从节点，但有且只能有一个主节点，在网络状态正常时，主节点会定时异步的把数据同步到从节点。

### 哨兵模式
    基于主从模型实现的哨兵监控网络，此时客户端应该直接连到哨兵服务，由哨兵负责提供具体实现
- 哨兵。监控Redis服务，会不停的监控主节点和从节点的信息，当主节点宕机时，会进行选举，选出一个从节点升级为主服务器，
  其它从节点改为复制新的主服务器；且当有请求访问原来的故障主服务器时，会返回新的主服务器地址，保证服务可用
- 哨兵网络。哨兵也是一个应用程序，存在宕机的可能，哨兵网络则是一组分布式的哨兵集合，网络中的哨兵会互相交换主从节点的健康状态，当有主节点宕机，则共同选举出一个新的主节点
  
### Cluster模式
- 哨兵和主从都是基于单机主服务器和多台从服务器的实现，不具备存储海量的数据，因此需要多台服务器组成的cluster模式，
- 实际上Cluster模式可以理解为多个主从模型+哨兵网络的结合实现，集群中每个节点仍然是一主多从的实现方案
- Cluster模式中所有节点互相连接，每个节点都记录整个集群的状态，即每个节点都既是哨兵又是存储器

### 集群
- 一个集群有16384个哈希槽，每个节点平均的负责一部分哈希槽，因此一个集群最多可以有16384个节点

### 管道技术
    客户端可以一下子提交多个命令，一次性执行，节省多次RTT的花销，但命令越多，缓存消耗越大，所以需要把控命令数量

### 持久化
- RDB持久化。每隔一段时间全量复制一份数据，完成之后覆盖上一次复制的文件。
- AOF持久化。将每一次数据的写操作追加到文件中，恢复时将整个文件的指令执行一遍。可选同步执行和每秒一次或者关闭。

